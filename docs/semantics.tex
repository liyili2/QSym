\documentclass[runningheads]{llncs}

\usepackage{proof}
\usepackage{stmaryrd}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{varwidth}
\usepackage{tikz}
\usepackage{tikz-cd}
% \usepackage{syntax}
% \usepackage{simplebnf}

\lstset{basicstyle=\ttfamily, mathescape=true, literate={~} {$\sim$}{1}}

\newcommand {\ra} {\rightarrow}
\newcommand {\labinfer} [3] [] {\infer[{\textsc{#1}}]{#2}{#3}}
\newcommand {\Type} {\textsf{Type}}
\newcommand {\Nat} {\textsf{Nat}}
\newcommand {\Bool} {\textsf{Bool}}
\newcommand {\Vect} {\textsf{Vec}}
\newcommand {\ok} {\text{ type}}
\newcommand {\Env} {\textsf{Env}}
\newcommand {\State} {\textsf{State}}
\newcommand {\Value} {\textsf{Value}}
\newcommand {\Locus} {\textsf{Locus}}
\newcommand {\Loc} {\textsf{Location}}
\newcommand {\sem} [1] {\llbracket #1 \rrbracket}
\newcommand {\Esem} [1] {E\sem{#1}}
\newcommand {\Expr} {\textsf{Expr}}
\newcommand {\Cmd} {\textsf{Stmt}}
\newcommand {\CmdTy} {\texttt{Stmt}}
\newcommand {\ExprTy} {\texttt{ExprTy}}
\newcommand {\Apply} {\textsf{Apply}}
\newcommand {\fst} {\ensuremath{\textsf{proj}_1}}
\newcommand {\snd} {\ensuremath{\textsf{proj}_2}}
\newcommand {\Var} {\textsf{Var}}
\newcommand {\Index} {\textsf{Index}}
\newcommand {\Cast} {\textsf{Cast}}
\newcommand {\Rename} {\textsf{Rename}}
\newcommand {\Permute} {\textsf{Permute}}
\newcommand {\loceq} {\approx}

\begin{document}

\title{Syntax and Semantics}
\author{}
\institute{}
\maketitle

\section{Testing Framework}

A QSym program can be divided up into two kinds of code:

\begin{enumerate}
  \item Classical parts (these use oracles)
  \item Quantum parts
\end{enumerate}

Information flows between these two kinds of code. The classical parts use \textit{symbolic} execution while the quantum parts are tested using \textit{concrete} execution. Together, these make up a \textit{concolic} testing framework for quantum programs. In Fig~\ref{fig:control-flow}, the classical code uses symbolic execution while the quantum code uses concrete execution.

\begin{figure}
% https://q.uiver.app/#q=WzAsNixbMCwxLCJcXHRleHRub3JtYWx7Q2xhc3NpY2FsIGNvZGV9Il0sWzEsMSwiXFx0ZXh0bm9ybWFse1F1YW50dW0gY29kZX0iXSxbMiwwLCJcXHRleHRub3JtYWx7Q2xhc3NpY2FsIGNvZGV9Il0sWzIsMiwiXFx0ZXh0bm9ybWFse0NsYXNzaWNhbCBjb2RlfSJdLFszLDEsIlxcdGV4dG5vcm1hbHtRdWFudHVtIGNvZGV9Il0sWzQsMSwiXFx0ZXh0bm9ybWFse0NsYXNzaWNhbCBjb2RlfSJdLFsxLDJdLFsxLDNdLFswLDFdLFsyLDRdLFszLDRdLFs0LDVdXQ==
\[\begin{tikzcd}
	&& {\textnormal{Classical code}} \\
	{\textnormal{Classical code}} & {\textnormal{Quantum code}} && {\textnormal{Quantum code}} & {\textnormal{Classical code}} \\
	&& {\textnormal{Classical code}}
	\arrow[from=1-3, to=2-4]
	\arrow[from=2-1, to=2-2]
	\arrow[from=2-2, to=1-3]
	\arrow[from=2-2, to=3-3]
	\arrow[from=2-4, to=2-5]
	\arrow[from=3-3, to=2-4]
\end{tikzcd}\]
  \caption{Control flow of representative program}
  \label{fig:control-flow}
\end{figure}

\section{Syntax}

  \begin{tabular}{lll}
    Locus\; & $\ell$ & ::= $x[i, j)$ $\mid$ $x[i, j) \uplus \ell$\\
    Expression\; & e & ::= $x$ $\mid$ $x[i,j)$ $\mid$ $e + e$ $\mid$ $e \cdot e$\\
    Statement\; & s & ::= s ; s $\mid$ $\Apply$ $\ell$ $e$ $\mid$ $\Cast$ $\ell$ $\ell$
  \end{tabular}

% \begin{center}
% \begin{bnf}
%   s : \Cmd ::= s ; s $\mid$ \Apply\;\ell\;e;;
% \end{bnf}
% \end{center}

\section{Typing Rules}

\[
  \begin{array}{c}
    \fbox{$\Gamma \vdash C : A$}
    \\\\
    \labinfer[T-Apply]{\Gamma \vdash \Apply\;\ell\;e : \CmdTy}
      {\Gamma, \ell \vdash e : \ExprTy}
  \end{array}
\]

\section{Denotational semantics}
    \fbox{
      \begin{minipage}{\textwidth}
      \[
      \begin{array}{ll}
        \Esem{\cdot} &{}: \Expr \ra \Locus^{+} \ra \State \ra \State\\
                \sem{\cdot} &{}: \Cmd \ra (\State \ra \State)\\
                \Permute &{}: (\Locus \times \Locus) \ra (\Value \ra \Value)\\
                \State &{}= \Loc \ra \Value\\
                \Loc &{}= \Var \times \Index\\
                \ell \loceq \ell
          \end{array}
        \]
      \end{minipage}
}

\subsection{Semantics of expressions}

\[
  \begin{array}{c}
    % \Esem{e_1, e_2}(a, b) = \Esem{e_2}(b) \circ \Esem{e_1}(a)\\\\
    \Esem{\ell}(b, \ell)\phi = \phi[\ell \mapsto b]
    % \Esem{e_1 + e_2}a = 
  \end{array}
\]

\subsection{Semantics of statements}

\subsubsection{``Apply'' semantics}

The expression $e$ in the command $\ell \Apply e$ will generally by an \textit{open} expression. That is, it typically has free variables. The value of this variable ranges over the quantum states. This is a kind of ``map'' operation over the (probability-weighted) possibilities. This amounts to applying the expression to every entry in the $\State$.

\subsubsection{Denotation}

\[
  \begin{array}{c}
    \sem{\Apply\;\ell\;e}\phi = \phi[(\ell, b) \mapsto
               (\ell, \Esem{e}(b, \ell)\phi)]\\\\
    \sem{\Cast\;\ell\;\ell'}\phi = \phi[(\ell', a) \mapsto (\ell, \Permute(\ell, \ell')(a))]\\\\
    \sem{c;c'} = \sem{c'} \circ \sem{c}
  \end{array}
\]

\textbf{TODO}: But what about the permutations?

\end{document}
